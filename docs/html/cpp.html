

<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Using the C++ interface &mdash; SubmodularStreamMaximization  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Library API" href="api/library_root.html" />
    <link rel="prev" title="Using the Python Interface" href="python.html" /> 

</head>

<body>
    <header>
        <div class="container">
            <a class="site-nav-toggle hidden-lg-up"><i class="icon-menu"></i></a>
            <a class="site-title" href="index.html">
                SubmodularStreamMaximization
            </a>
        </div>
    </header>


<div class="breadcrumbs-outer hidden-xs-down">
    <div class="container">
        















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="breadcrumbs">
    
      <li><a href="index.html">Docs</a></li>
        
      <li>Using the C++ interface</li>
    
    
      <li class="breadcrumbs-aside">
        
            
            <a href="_sources/cpp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>
</div>
    </div>
</div>
    <div class="main-outer">
        <div class="container">
            <div class="row">
                <div class="col-12 col-lg-3 site-nav">
                    
<div role="search">
    <form class="search" action="search.html" method="get">
        <div class="icon-input">
            <input type="text" name="q" placeholder="Search" />
            <span class="icon-search"></span>
        </div>
        <input type="submit" value="Go" class="d-hidden" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
    </form>
</div>
                    <div class="site-nav-tree">
                        
                            
                            
                                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="root.html">SubmodularStreamMaximization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="root.html#how-to-install">How to install</a></li>
<li class="toctree-l2"><a class="reference internal" href="root.html#how-to-reproduce-the-experiments-in-our-paper">How to reproduce the experiments in our paper</a></li>
<li class="toctree-l2"><a class="reference internal" href="root.html#cite-our-paper">Cite our paper</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="python.html">Using the Python Interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="python.html#implementing-a-custom-kernel-for-the-ivm">Implementing a custom kernel for the IVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="python.html#implementing-custom-submodular-functions">Implementing custom submodular functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="python.html#implementing-your-own-optimizer">Implementing your own optimizer</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Using the C++ interface</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#implementing-a-custom-kernel-for-the-ivm">Implementing a custom kernel for the IVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementing-custom-submodular-functions">Implementing custom submodular functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementing-your-own-optimizer">Implementing your own optimizer</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api/library_root.html">Library API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="api/library_root.html#class-hierarchy">Class Hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/library_root.html#file-hierarchy">File Hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="api/library_root.html#full-api">Full API</a></li>
</ul>
</li>
</ul>

                            
                        
                    </div>
                </div>
                <div class="col-12 col-lg-9">
                    <div class="document">
                        
                            
  <div class="section" id="using-the-c-interface">
<h1>Using the C++ interface<a class="headerlink" href="#using-the-c-interface" title="Permalink to this headline">¶</a></h1>
<p>The C++ code is header-only so simply include the desired functions in your project and your are good to go. However, you require a C++17 compiler (e.g. gcc-7 or clang-5). If you have trouble compiling you can look at the <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> file which compiles the Python bindings as well as the test files For a detailed explanation on specific parameters / functions provided please have a look at the documentation of the individual optimizers. Generally, each optimizer provides</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fit(X)</span></code>: Selects a summary of the given data set (batch processing)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">next(x)</span></code>: Consumes the next data item from a stream  (stream processing)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_solution()</span></code>: Returns the current solution</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_ids()</span></code>: Returns the id (if any) of each object</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_num_candidate_solutions</span></code>: Returns the number of intermediate solutions stored by the optimizer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_num_elements_stored</span></code>: Returns the number of elements stored by the optimizer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_fval</span></code>: Returns the function value</p></li>
</ul>
<p>The following example uses the Greedy optimizer to select a data summary by maximizing the Informative Vector Machine (the full examples can be found in <code class="docutils literal notranslate"><span class="pre">tests/main.cpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;FastIVM.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;RBFKernel.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;Greedy.h&quot;</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
      <span class="p">{</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">},</span>
      <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">},</span>
      <span class="p">{</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
      <span class="p">{</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">},</span>
      <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">FastIVM</span> <span class="nf">fastIVM</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">RBFKernel</span><span class="p">(),</span> <span class="mf">1.0</span><span class="p">);</span>

<span class="n">Greedy</span> <span class="nf">greedy</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">fastIVM</span><span class="p">)</span>
<span class="n">greedy</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">solution</span> <span class="o">=</span> <span class="n">greedy</span><span class="p">.</span><span class="n">get_solution</span><span class="p">();</span>
<span class="kt">double</span> <span class="n">fval</span> <span class="o">=</span> <span class="n">greedy</span><span class="p">.</span><span class="n">get_fval</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Found a solution with fval = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fval</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">solution</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">xi</span> <span class="p">:</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">xi</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="implementing-a-custom-kernel-for-the-ivm">
<h2>Implementing a custom kernel for the IVM<a class="headerlink" href="#implementing-a-custom-kernel-for-the-ivm" title="Permalink to this headline">¶</a></h2>
<p>Implementing your own custom kernel is easy. To do so, there are two options. Either you simply implement a regular function accepting two arguments <cite>x1</cite> and <cite>x2</cite> and  pass them to the IVM / FastIVM object. We recommend this approach for stateless kernel functions.
Alternatively, you can extend the <cite>Kernel</cite> class by implementing the <cite>clone</cite> method and the <cite>operator()</cite> method. The <cite>clone</cite> method must return a <cite>shared_ptr</cite> to a clone (__not__ a copy) of the object, whereas the <cite>operator()</cite> method accepts the two instances <cite>x1</cite> and <cite>x2</cite>. Use this approach if you want to implement a stateful kernel.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">data_t</span> <span class="nf">poly_kernel</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;&amp;</span> <span class="n">x2</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">data_t</span> <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">x1</span> <span class="o">!=</span> <span class="n">x2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">distance</span> <span class="o">+=</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">distance</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">class</span> <span class="nc">PolyKernel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Kernel</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="n">PolyKernel</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

   <span class="kr">inline</span> <span class="n">data_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;&amp;</span> <span class="n">x1</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;&amp;</span> <span class="n">x2</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
       <span class="n">data_t</span> <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">x1</span> <span class="o">!=</span> <span class="n">x2</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
               <span class="n">distance</span> <span class="o">+=</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
         <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">distance</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Kernel</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Kernel</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">PolyKernel</span><span class="p">());</span>
   <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="implementing-custom-submodular-functions">
<h2>Implementing custom submodular functions<a class="headerlink" href="#implementing-custom-submodular-functions" title="Permalink to this headline">¶</a></h2>
<p>Implementing your own submodular function is easy. Again there are two options: First, you simply provide a regular function which evaluates the function value of the provided summary <cite>X</cite>. Any optimizer accepts these regular functions and an example is given below which computes the logdet of the kernel matrix via the Matrix class. We recommend this approach if you want to implement stateless submodular functions.</p>
<p>Re-computing the kernel matrix can become slow for larger summaries. Thus, you can also implement the SubmodularFunction interface directly to cache computations. To do so, you have to implement the <cite>peek</cite>, the <cite>update</cite>, the <cite>clone</cite> and the <cite>operator()</cite>  method. For more details please see the dedicated documentation for SubmodularFunction. An example is given below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="n">data_t</span> <span class="nf">logdet</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">cur_solution</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
   <span class="n">Matrix</span> <span class="n">kmat</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>

   <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">data_t</span> <span class="n">kval</span> <span class="o">=</span> <span class="n">poly_kernel</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
               <span class="n">kmat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">kval</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
               <span class="n">kmat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">kval</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
               <span class="n">kmat</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">kval</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
            <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">log_det</span><span class="p">(</span><span class="n">kmat</span><span class="p">,</span> <span class="n">cur_solution</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>


<span class="k">class</span> <span class="nc">FastLogDet</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SubmodularFunction</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>

<span class="k">protected</span><span class="o">:</span>
   <span class="c1">// Number of items added so far. Required to maintain consistent access to kmat and L</span>
   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">added</span><span class="p">;</span>

   <span class="c1">// The kernel matrix \Sigma.</span>
   <span class="c1">// See Matrix.h for more details</span>
   <span class="n">Matrix</span> <span class="n">kmat</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

   <span class="n">FastIVM</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span> <span class="o">:</span> <span class="n">kmat</span><span class="p">(</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="p">}</span>


   <span class="n">data_t</span> <span class="n">peek</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">cur_solution</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">added</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Peek function value for last line</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">added</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
               <span class="n">data_t</span> <span class="n">kval</span> <span class="o">=</span> <span class="n">poly_kernel</span><span class="p">(</span><span class="n">cur_solution</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">);</span>

               <span class="n">kmat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">added</span><span class="p">)</span> <span class="o">=</span> <span class="n">kval</span><span class="p">;</span>
               <span class="n">kmat</span><span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">kval</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">data_t</span> <span class="n">kval</span> <span class="o">=</span> <span class="n">poly_kernel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
            <span class="n">kmat</span><span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="n">added</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">kval</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">added</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
               <span class="c1">//data_t s = std::inner_product(&amp;L[added * K], &amp;L[added * K] + j, &amp;L[j * K], static_cast&lt;data_t&gt;(0));</span>
               <span class="n">data_t</span> <span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">inner_product</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
               <span class="k">if</span> <span class="p">(</span><span class="n">added</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                  <span class="n">L</span><span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kmat</span><span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">);</span>
               <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                  <span class="n">L</span><span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0f</span> <span class="o">/</span> <span class="n">L</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">kmat</span><span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">));</span>
               <span class="p">}</span>
               <span class="n">L</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">added</span><span class="p">)</span> <span class="o">=</span> <span class="n">L</span><span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="c1">// Symmetric update</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">fval</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">log</span><span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="n">added</span><span class="p">));</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">Matrix</span> <span class="nf">tmp</span><span class="p">(</span><span class="n">kmat</span><span class="p">,</span> <span class="n">added</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cur_solution</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
               <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
                  <span class="n">data_t</span> <span class="n">kval</span> <span class="o">=</span> <span class="n">poly_kernel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
                  <span class="n">tmp</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">kval</span><span class="p">;</span>
               <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                  <span class="n">data_t</span> <span class="n">kval</span> <span class="o">=</span> <span class="n">poly_kernel</span><span class="p">(</span><span class="n">cur_solution</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">);</span>
                  <span class="n">tmp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="o">=</span> <span class="n">kval</span><span class="p">;</span>
                  <span class="n">tmp</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">kval</span><span class="p">;</span>
               <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">log_det</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">cur_solution</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">added</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fval</span> <span class="o">=</span> <span class="n">peek</span><span class="p">(</span><span class="n">cur_solution</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
            <span class="n">added</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cur_solution</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
               <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
                  <span class="n">data_t</span> <span class="n">kval</span> <span class="o">=</span> <span class="n">poly_kernel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
                  <span class="n">kmat</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">kval</span><span class="p">;</span>
               <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                  <span class="n">data_t</span> <span class="n">kval</span> <span class="o">=</span> <span class="n">poly_kernel</span><span class="p">(</span><span class="n">cur_solution</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">);</span>
                  <span class="n">kmat</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="o">=</span> <span class="n">kval</span><span class="p">;</span>
                  <span class="n">kmat</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">kval</span><span class="p">;</span>
               <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">(</span><span class="n">kmat</span><span class="p">,</span> <span class="n">added</span><span class="p">);</span>
            <span class="n">fval</span> <span class="o">=</span> <span class="n">log_det_from_cholesky</span><span class="p">(</span><span class="n">L</span><span class="p">);</span>
      <span class="p">}</span>

   <span class="p">}</span>

   <span class="n">data_t</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">cur_solution</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">log_det</span><span class="p">(</span><span class="n">kmat</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SubmodularFunction</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
      <span class="c1">// We want to store k elements. To allow for efficient peeking we will reserve space for K + 1 elements in kmat and L.</span>
      <span class="c1">// Thus we need to call the constructor with one element less</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">FastIVM</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kmat</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="implementing-your-own-optimizer">
<h2>Implementing your own optimizer<a class="headerlink" href="#implementing-your-own-optimizer" title="Permalink to this headline">¶</a></h2>
<p>Implementing your own optimizer is more challenging and requires some background in Python and C++. To do so, you first must implement the SubmodularOptimizer interface which requires you to implement the <cite>next(std::vector&lt;data_t&gt; const &amp;x, std::optional&lt;idx_t&gt; const id = std::nullopt)</cite> method. The <cite>next</cite> method consumes the next item in the data stream and – depending on the method – adds it to the summary or not. An optional identifier is also supplied which might be used to uniquely identify items  from the stream. Make sure to correctly call <cite>update</cite> and <cite>peek</cite>/<cite>operator</cite> of the SubmodularFunction to store the correct function values. In addition, you must provide two constructors for your optimizer which both accept the number of elements to select K as well as the submodular function (either as <cite>std::function</cite> or as SubmodularFunction object). For more information please consult the documentation of the SubmodularOptimizer interface. As a simple example consider the following random sampling algorithm which uses reservoir sampling:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Random</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SubmodularOptimizer</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">generator</span><span class="p">;</span>

   <span class="k">static</span> <span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">idx_t</span><span class="o">&gt;</span> <span class="n">sample_without_replacement</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span><span class="o">&amp;</span> <span class="n">gen</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Create an unordered set to store the samples</span>
      <span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">idx_t</span><span class="o">&gt;</span> <span class="n">samples</span><span class="p">;</span>

      <span class="c1">// Sample and insert values into samples</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">k</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">idx_t</span> <span class="n">v</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)(</span><span class="n">gen</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">samples</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">).</span><span class="n">second</span><span class="p">)</span> <span class="n">samples</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// Copy samples into vector</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">idx_t</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">samples</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">samples</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

      <span class="c1">// Shuffle vector</span>
      <span class="n">std</span><span class="o">::</span><span class="n">shuffle</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">gen</span><span class="p">);</span>

      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
   <span class="p">};</span>

<span class="k">public</span><span class="o">:</span>

   <span class="n">Random</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">K</span><span class="p">,</span> <span class="n">SubmodularFunction</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">SubmodularOptimizer</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="n">generator</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span> <span class="p">{}</span>

   <span class="n">Random</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">K</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">data_t</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">SubmodularOptimizer</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">f</span><span class="p">),</span> <span class="n">generator</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span> <span class="p">{}</span>

   <span class="kt">void</span> <span class="n">next</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">idx_t</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">solution</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Just add the first K elements</span>
            <span class="n">f</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">solution</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
            <span class="n">solution</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="n">ids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">value</span><span class="p">());</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Sample the replacement-index with decreasing probability</span>
            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cnt</span><span class="p">)(</span><span class="n">generator</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
               <span class="n">f</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
               <span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="n">ids</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
               <span class="n">solution</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
            <span class="p">}</span>
      <span class="p">}</span>

      <span class="c1">// Update the current function value</span>
      <span class="n">fval</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="k">operator</span><span class="p">()(</span><span class="n">solution</span><span class="p">);</span>
      <span class="n">is_fitted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If you only want to use the C++ interface, then you are already done after implementing your class. If you also want to expose the implementation to Python then you will need to implement additional PyBind bindings. To do so, you need to add your bindings to <cite>Python.cpp</cite>. Please consult the PyBind documentation if you are not familiar with PyBind. In most cases however the pattern usually looks something like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">MyNewOptimizer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">&quot;MyNewOptimizer&quot;</span><span class="p">)</span>
     <span class="cm">/* These are the constructor definitions for your optimizer which probably include some additional options. Make sure that the data-types match. */</span>
     <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">SubmodularFunction</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;K&quot;</span><span class="p">),</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">),</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;option1&quot;</span><span class="p">)</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
     <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">data_t</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;K&quot;</span><span class="p">),</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">),</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;option1&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
     <span class="cm">/* These functions are likely unchanged */</span>
     <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_solution&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyNewOptimizer</span><span class="o">::</span><span class="n">get_solution</span><span class="p">)</span>
     <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_ids&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyNewOptimizer</span><span class="o">::</span><span class="n">get_ids</span><span class="p">)</span>
     <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_fval&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyNewOptimizer</span><span class="o">::</span><span class="n">get_fval</span><span class="p">)</span>
     <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_num_candidate_solutions&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyNewOptimizer</span><span class="o">::</span><span class="n">get_num_candidate_solutions</span><span class="p">)</span>
     <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_num_elements_stored&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyNewOptimizer</span><span class="o">::</span><span class="n">get_num_elements_stored</span><span class="p">)</span>
     <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;fit&quot;</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">overload_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyNewOptimizer</span><span class="o">::</span><span class="n">fit</span><span class="p">),</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">),</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;iterations&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
     <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;fit&quot;</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">overload_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">data_t</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">idx_t</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MyNewOptimizer</span><span class="o">::</span><span class="n">fit</span><span class="p">),</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">),</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;ids&quot;</span><span class="p">),</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;iterations&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
     <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;next&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyNewOptimizer</span><span class="o">::</span><span class="n">next</span><span class="p">,</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">),</span> <span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that we use the <cite>clone</cite> function of SubmodularFunction in the constructor to make sure that stateful functions do not have side-effects. Moreover, we try to stick to “modern” C++ utilizing the stl when possible / helpful. Last, you are free to override more functions from the SubmodularOptimizer interface and/or expose more functions to the python-side. For example, we may also override the <cite>fit</cite> function in the above Random example to directly sample data-points instead of using reservoir sampling.</p>
</div>
</div>


                        
                    </div>
                </div>
            </div>
        </div>
    </div>    


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
    <script type="text/javascript" src="_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script type="text/javascript" src="_static/js/theme.js"></script>
  
    <div class="footer" role="contentinfo">
        <div class="container">
            &#169; Copyright 2021, Sebastian Buschjäger.
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.0.3.
        </div>
    </div>  

</body>
</html>